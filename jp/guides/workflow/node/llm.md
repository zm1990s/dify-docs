# LLM

### 定義

大規模言語モデルを活用して質問に回答したり、自然言語を処理したりします。

<figure><img src="../../../.gitbook/assets/jp-llm-detail.png" alt=""><figcaption><p>LLM ノード</p></figcaption></figure>

***

### シナリオ

LLM は チャットフロー/ワークフロー の中心的なノードであり、大規模言語モデルの会話/生成/分類/処理などの能力を活用して、多様なタスクを提示されたプロンプトに基づいて処理し、ワークフローのさまざまな段階で使用することができます。

* **意図識別**：カスタマーサービスの対話シナリオにおいて、ユーザーの質問を意図識別および分類し、異なるフローに誘導します。
* **テキスト生成**：記事生成シナリオにおいて、テーマやキーワードに基づいて適切なテキスト内容を生成するノードとして機能します。
* **内容分類**：メールのバッチ処理シナリオにおいて、メールの種類を自動的に分類します（例：問い合わせ/苦情/スパム）。
* **テキスト変換**：テキスト翻訳シナリオにおいて、ユーザーが提供したテキスト内容を指定された言語に翻訳します。
* **コード生成**：プログラミング支援シナリオにおいて、ユーザーの要求に基づいて指定のビジネスコードやテストケースを生成します。
* **RAG**：ナレッジベースの質問応答シナリオにおいて、検索した関連知識とユーザーの質問を再構成して回答します。
* **画像理解**：ビジョン能力を持つマルチモーダルモデルを使用し、画像内の情報を理解して質問に回答します。
* **ファイル分析**：ファイルを処理する場合、LLMsを活用して、ファイルに含まれている情報を認識し、それを分析することができます。

適切なモデルを選択し、プロンプトを記述することで、チャットフロー/ワークフロー で強力で信頼性の高いソリューションを構築できます。

***

### 設定方法

エディットページで、前のノードの末尾を右クリックするか、+ボタンを軽くタップして新しいノードを追加し、LLM（大規模言語モデル）を選択します。

<figure><img src="../../../.gitbook/assets/jp-llm-model.png" alt=""><figcaption><p>LLM ノード設定 - モデル選択</p></figcaption></figure>

**設定手順：**

1. **モデルの選択**：Difyでは、OpenAIのGPTシリーズ、AnthropicのClaudeシリーズ、GoogleのGeminiシリーズなど、世界中で広く使用されているさまざまなモデルを[サポート](../../../getting-started/readme/model-providers.md)しています。モデルの選択は、推論能力、コスト、応答速度、コンテキストウィンドウのサイズなどの要因に基づいて行います。使用するシーンやタスクの種類に応じて、適切なモデルを選ぶことが重要です。

{% hint style="info" %}
Difyを初めて使用する場合は、LLMノードでモデルを選択する前に、**システム設定 - モデルプロバイダ**で[モデルの設定](../../model-configuration/)を事前に行う必要があります。
{% endhint %}

2. **モデルパラメータの設定**：モデルパラメータは、生成される結果を調整するために使用されます。これには、温度、TopP、最大トークン数、応答形式などが含まれます。選択肢を簡素化するために、3つの事前設定されたパラメータ（クリエイティブ、バランス、精密）が用意されています。これらのパラメータに不慣れな場合は、デフォルト設定を選択することをお勧めします。画像解析機能を利用したい場合は、視覚能力を持つモデルを選んでください。

3. **コンテキストの入力（オプション）**：コンテキストとは、LLMに提供される背景情報のことを指します。通常は、[知識検索](knowledge-retrieval.md)の出力変数を記入するために使用されます。

4. **プロンプトの作成**：LLMノードには使いやすいプロンプト編集ページがあり、チャットモデルまたはコンプリートモデルを選択することで異なるプロンプト編集構造が表示されます。チャットモデル（Chat model）を選択した場合、システムプロンプト（SYSTEM）、ユーザー（USER）、アシスタント（ASSISTANT）の3つのセクションをカスタマイズできます。

<figure><img src="../../../.gitbook/assets/jp-llm-customize.png" alt="" width="352"><figcaption><p>プロンプトの作成</p></figcaption></figure>

システムプロンプト（SYSTEM）を作成する際にアイデアが浮かばない場合は、プロンプトジェネレーター機能を使用して、実際のビジネスシナリオに適したプロンプトを迅速に生成することができます。

![プロンプトジェネレーター](../../../.gitbook/assets/jp-node-llm-prompt-generator.png)

プロンプトエディターでは、**“/”** または **“{”** を入力することで **変数挿入メニュー**を呼び出し、**特殊変数ブロック**や **上流ノードの変数**をプロンプトに挿入してコンテキスト内容として使用できます。

<figure><img src="../../../.gitbook/assets/jp-llm-variable.png" alt="" width="366"><figcaption><p>変数挿入メニューを呼び出す</p></figcaption></figure>

5. **上級的な設定**：メモリ機能をオンにしたり、メモリウィンドウを設定したり、ビジョン機能を有効にしたり、Jinja-2テンプレート言語を使ってより複雑なプロンプトを作成したりできます。

***

### **特殊変数の説明**

**コンテキスト変数**

コンテキスト変数とは、LLMノードで定義される特別な変数で、これを使って外部から収集したテキストをプロンプトに挿入することができます。

<figure><img src="../../../../en/.gitbook/assets/llm-node-4.png" alt=""><figcaption><p>Context Variables</p></figcaption></figure>

一般的な知識ベースのQ&Aアプリケーションにおいては、知識を取得する部分（下流ノード）は普通、LLMノードになります。この知識取得による**出力変数**`result`は、LLMノード内の**コンテキスト変数**に関連付けて設定する必要があります。この関連付けにより、**コンテキスト変数**をプロンプトの適切な場所に挿入することで、外部からの知識をプロンプトに組み込むことが可能になります。

この変数は外部知識をLLMの応答のためのプロンプトに取り入れる役割だけでなく、セグメント参照情報を含んだデータ構造を通して、アプリケーションの [**引用と帰属**](../../knowledge-base/retrieval-test-and-citation#id-2-to) 機能を支えるものでもあります。

{% hint style="info" %}
もしコンテキスト変数が上流ノードの一般的な変数、例えばスタートノードからの文字列タイプの変数と関連付けられた場合、その変数は外部知識としては使えますが、**「引用と帰属」**機能は使えなくなります。
{% endhint %}

**ファイル変数**

多くの大規模言語モデル（LLM）は、[Claude 3.5 Sonnet](https://docs.anthropic.com/en/docs/build-with-claude/pdf-support)の例にもあるように、ファイルの内容を直接扱える機能を提供しています。これにより、プロンプトにファイル変数を用いることが可能となります。しかし、開発者がファイル変数を使用する際には、事前にそのLLMが対応しているファイル形式を、公式サイトで確認することが重要です。これは、予期せぬ問題を避けるためです。

![](https://assets-docs.dify.ai/2024/11/05b3d4a78038bc7afbb157078e3b2b26.png)

> チャットフローやワークフローアプリケーションでファイルアップロード機能を組み込む方法については、[ファイルアップロードガイド](https://docs.dify.ai/ja-jp/guides/workflow/file-upload)をご覧ください。

**会話履歴**

テキスト補完モデル（例：gpt-3.5-turbo-Instruct）内でチャット型アプリケーションの対話記憶を実現するために、Dify は元の[プロンプト専門モード（廃止）](https://docs.dify.ai/v/ja-jp/learn-more/extended-reading/prompt-engineering/prompt-engineering)内で会話履歴変数を設計しました。この変数は チャットフロー の LLM ノード内でも使用され、プロンプト内に AI とユーザーの対話履歴を挿入して、LLM が対話の文脈を理解するのを助けます。

{% hint style="info" %}
会話履歴変数の使用は広範ではなく、チャットフロー 内でテキスト補完モデルを選択した場合にのみ使用できます。
{% endhint %}

<figure><img src="../../../.gitbook/assets/jp-llm-with-histories.png" alt=""><figcaption><p>会話履歴変数の挿入</p></figcaption></figure>

**モデルパラメーター**

モデルのパラメータはモデルの出力に影響を与えます。異なるモデルには異なるパラメータがあります。以下の図は`gpt-4`のパラメータリストです。

<figure><img src="../../../.gitbook/assets/jp-llm-model-provider-1.png" alt="" width="363"><figcaption></figcaption></figure>

主要なパラメータ用語は以下のように説明されています：

**Temperature(温度)**: 通常は0-1の値で、ランダム性を制御します。温度が0に近いほど、結果はより確定的で繰り返しになり、温度が1に近いほど、結果はよりランダムになります。

**Top P**: 結果の多様性を制御します。モデルは確率に基づいて候補語から選択し、累積確率が設定された閾値Pを超えないようにします。

**Presence Penalty(存在ペナルティ)**: 既に生成された内容にペナルティを課すことにより、同じエンティティや情報の繰り返し生成を減少させるために使用されます。パラメータ値が増加するにつれて、既に生成された内容に対して後続の生成でより大きなペナルティが課され、内容の繰り返しの可能性が低くなります。

**Frequency Penalty(頻度ペナルティ)**: 頻繁に出現する単語やフレーズにペナルティを課し、これらの単語の生成確率を低下させます。パラメータ値が増加すると、頻繁に出現する単語やフレーズにより大きなペナルティが課されます。パラメータ値が高いほど、これらの単語の出現頻度が減少し、テキストの語彙の多様性が増加します。

これらのパラメータが何であるか理解できない場合は、プリセットを読み込んで、「クリエイティブ」、「バランス」、「正確」の3つのプリセットから選択することができます。

<figure><img src="../../../.gitbook/assets/jp-llm-model-provider-2.png" alt="" width="367"><figcaption></figcaption></figure>

***

### 高度な機能

**記憶**：記憶をオンにすると、問題分類器の各入力に対話履歴が含まれ、LLM が文脈を理解しやすくなり、対話の理解能力が向上します。

**記憶ウィンドウ**：記憶ウィンドウが閉じている場合、システムはモデルのコンテキストウィンドウに基づいて対話履歴の伝達数を動的にフィルタリングします。開いている場合、ユーザーは対話履歴の伝達数を正確に制御できます（対数）。

**対話役割名の設定**：モデルのトレーニング段階の違いにより、異なるモデルは役割名のプロンプト遵守度が異なります（例：Human/Assistant、Human/AI、人間/助手など）。複数のモデルに対応するために、システムは対話役割名の設定を提供しており、対話役割名を変更すると会話履歴の役割プレフィックスも変更されます。

**Jinja-2 テンプレート**：LLM のプロンプトエディター内で Jinja-2 テンプレート言語をサポートしており、Jinja2 の強力な Python テンプレート言語を使用して軽量なデータ変換やロジック処理を実現できます。詳細は[公式ドキュメント](https://jinja.palletsprojects.com/en/3.1.x/templates/)を参照してください。

***

### 活用事例

* **ナレッジベースの内容を検索する**

ワークフローアプリケーションが[「ナレッジベース」](../../knowledge-base/)の内容を検索できるようにしたい場合、例えばインテリジェントカスタマーサービスアプリケーションを構築する場合は、以下の手順を参考にしてください。

1. LLMノードの上流に知識検索ノードを追加します；
2. 知識検索ノードの **出力変数** `result` をLLMノードの **コンテキスト変数** に入力します；
3. **コンテキスト変数** をアプリケーションのプロンプトに挿入し、LLMがナレッジベース内のテキスト内容を読み取れるようにします。

<figure><img src="../../../../en/.gitbook/assets/image (135).png" alt=""><figcaption><p>コンテキスト変数</p></figcaption></figure>

[知識検索ノード](knowledge-retrieval.md) の出力変数 `result` には引用情報も含まれており、[**引用と帰属**](../../knowledge-base/retrieval-test-and-citation.md#id-2-yin-yong-yu-gui-shu) 機能を使用して情報の出所を確認できます。

{% hint style="info" %}
通常のノードの変数もコンテキスト変数に入力可能ですが、例えば開始ノードの文字列型変数など、**引用と帰属** 機能は機能しません。
{% endhint %}

* **文書ファイルの読み取り**

ChatPDF アプリケーションの構築など、ワークフロー アプリケーションにドキュメントのコンテンツを読み取る機能を提供する場合は、次を参照してください。

<!-- * **文書内容を抽出する**

ワークフローアプリケーションに文書内容を抽出する機能を持たせたい場合、例えばChatPDFアプリケーションを構築する場合は、以下の手順を実行してください。

* 「開始」ノードにファイル変数を追加します；
* LLMノードの上流に文書抽出ノードを追加し、ファイル変数を入力変数として使用します；
* 文書抽出ノードの **出力変数** `text` をLLMノードのプロンプトに入力します。

詳細については、[ファイルのアップロード](../file-upload.md)をご参照ください。 -->

<!-- <figure><img src="../../../.gitbook/assets/image (2).png" alt=""><figcaption><p>出力変数の入力</p></figcaption></figure> -->